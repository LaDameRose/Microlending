
```{r}
library(zoo)
library(fpp2)
library(seasonal)
library(clustMixType)
library(outliers)
library(mixtools)
library(MASS)
library(caret)
library(rpart)
```

Remove records where funded_time is missing
```{r}
loan_clean <- loan[is.na(loan$funded_time)== FALSE,]
```

Create unix funded_time
```{r}
loan_clean$funded_time_unix <- as.numeric(as.POSIXct(loan_clean$funded_time))
```

Create unix posted_time
```{r}
loan_clean$posted_time_unix <- as.numeric(as.POSIXct(loan_clean$posted_time))
```

Create duration
```{r}
loan_clean$duration <- loan_clean$funded_time_unix - loan_clean$posted_time_unix
```
Remove negative duration
```{r}
loan_clean <- loan_clean[loan_clean$duration > 0,]
```

Equivalize duration by funded_amount
```{r}
loan_clean$duration_perdollar <- loan_clean$duration - loan_clean$funded_amount
```

Remove records where funded_amount is different from loan_amount, ie loan was not fully funded
```{r}
loan_clean <- loan_clean[loan_clean$funded_amount - loan_clean$loan_amount == 0,]
```

Create variable for funded year/month for time series
```{r}
loan_clean$funded_yearmonth <- format(as.Date(loan_clean$funded_time), "%Y/%m")
```

Create variable for funded year/month/day for time series
```{r}
loan_clean$funded_yearmonthday <- format(as.Date(loan_clean$funded_time), "%Y/%m/%d")
```

Create variable for posted year/month for time series
```{r}
loan_clean$posted_yearmonth <- format(as.Date(loan_clean$posted_time), "%Y/%m")
```

Building time series with funded month year using decompose()
```{r}
loan_clean_tsa_funded <- loan_clean[,c(1,25)]
loan_clean_tsa_funded <- aggregate(loan_clean_tsa_funded, by=list(loan_clean_tsa_funded$funded_yearmonth), FUN=length)
loan_clean_tsa_funded <- loan_clean_tsa_funded[2:42,c(1,3)]
loan_clean_tsa_funded$Group.1 <- as.Date(paste0(loan_clean_tsa_funded$Group.1,"/01"), "%Y/%m/%d")
names(loan_clean_tsa_funded)[1] <- "yearmonth"
ts_loan_clean_tsa_funded <- ts(loan_clean_tsa_funded$funded_yearmonth,start = c(2014,2), end = c(2017,6), frequency = 12)
plot(ts_loan_clean_tsa_funded)
decompose_funded <- decompose(ts_loan_clean_tsa_funded,"multiplicative")
plot(decompose_funded)
plot.ts(decompose_funded$seasonal)
decompose_funded$seasonal
plot.ts(decompose_funded$trend)
decompose_funded$trend
plot.ts(decompose_funded$random)
decompose_funded$random
summary(decompose_funded)
```

Building time series with posted month year using decompose()
```{r}
loan_clean_tsa_posted <- loan_clean[,c(1,27)]
loan_clean_tsa_posted <- aggregate(loan_clean_tsa_posted, by=list(loan_clean_tsa_posted$posted_yearmonth), FUN=length)
loan_clean_tsa_posted <- loan_clean_tsa_posted[2:42,c(1,3)]
loan_clean_tsa_posted$Group.1 <- as.Date(paste0(loan_clean_tsa_posted$Group.1,"/01"), "%Y/%m/%d")
names(loan_clean_tsa_posted)[1] <- "yearmonth"
ts_loan_clean_tsa_posted <- ts(loan_clean_tsa_posted$posted_yearmonth,start = c(2014,2), end = c(2017,6), frequency = 12)
plot(ts_loan_clean_tsa_posted)
decompose_posted <- decompose(ts_loan_clean_tsa_posted,"multiplicative")
plot(decompose_posted)
plot.ts(decompose_posted$seasonal)
decompose_posted$seasonal
plot.ts(decompose_posted$trend)
decompose_posted$trend
plot.ts(decompose_posted$random)
decompose_posted$random
summary(decompose_posted)
```
Building time series with funded month year using stl()
```{r}
stl_funded <- stl(log(ts_loan_clean_tsa_funded),"periodic")
seasonal_stl_funded <- exp(stl_funded$time.series[,1])
trend_stl_funded <- exp(stl_funded$time.series[,2])
random_stl_funded <- stl_funded$time.series[,3]
plot(stl_funded)
plot.ts(seasonal_stl_funded)
seasonal_stl_funded
plot.ts(trend_stl_funded)
trend_stl_funded

plot.ts(random_stl_funded)
random_stl_funded
summary(stl_funded)
```

Building time series with funded month year using seas() for X11
```{r}
seasx11_funded <- seas(ts_loan_clean_tsa_funded,x11="")
seasonal_x11_funded <- seasonal(seasx11_funded)
trend_x11_funded <- trendcycle(seasx11_funded)
remain_x11_funded <- remainder(seasx11_funded)
autoplot(seasx11_funded)
plot.ts(seasonal_x11_funded)
seasonal_x11_funded
plot.ts(trend_x11_funded)
trend_x11_funded
plot.ts(remain_x11_funded)
remain_x11_funded
summary(seasx11_funded)
```

Building time series with funded month year using seas() for SEATS
```{r}
seats_funded <- seas(ts_loan_clean_tsa_funded)
seasonal_seats_funded <- seasonal(seats_funded)
trend_seats_funded <- trendcycle(seats_funded)
remain_seats_funded <- remainder(seats_funded)
autoplot(seats_funded)
plot.ts(seasonal_seats_funded)
seasonal_seats_funded
plot.ts(trend_seats_funded)
trend_seats_funded
plot.ts(remain_seats_funded)
remain_seats_funded
summary(seats_funded)
```

Comparing time series using Pearson correlation
```{r}
cor(cbind(random_stl_funded,remain_x11_funded,remain_seats_funded))
```

Cleaning: take out unecessary variables, reduce gender to 3 levels, change yearmonth to factor, remove gender = NA
```{r}
loan_clean_red <- loan_clean[,c(2,5,8,15,18,19,24,25,27)]
loan_clean_red$borrower_genders <- as.factor(ifelse(loan_clean_red$borrower_genders == "male", "M", ifelse(loan_clean_red$borrower_genders == "female", "F","G")))
loan_clean_red$funded_yearmonth <- as.factor(loan_clean_red$funded_yearmonth)
loan_clean_red$posted_yearmonth <- as.factor(loan_clean_red$posted_yearmonth)
loan_clean_red <- loan_clean_red[is.na(loan_clean_red$borrower_genders) == FALSE,]
```

Determining optimal number of clusters by running 1 to 15 clusters and evaluating total wws
```{r}
k.max <- 15
wss <- sapply(1:k.max, 
              function(k){kproto(loan_clean_red, k)$tot.withinss})
wss
plot(1:k.max, wss,
     type="b", pch = 19, frame = FALSE, 
     xlab="Number of clusters K",
     ylab="Total within-clusters sum of squares")
```

Running K prototype with 6 clusters
```{r}
loan_cluster <- kproto(loan_clean_red,6)
loan_cluster
```

remove outliers in funded amount
```{r}
loan_clean_red_out <- loan_clean_red[scores(loan_clean_red$funded_amount,type="chisq", prob=0.95) == FALSE,]
loan_clean_red_out <- loan_clean_red_out[loan_clean_red_out$funded_amount != outlier(loan_clean_red_out$funded_amount, opposite = TRUE),]
hist(loan_clean_red_out$funded_amount)
hist(log(loan_clean_red_out$funded_amount))
summary(loan_clean_red_out$funded_amount)
```

remove outliers in term in months
```{r}
loan_clean_red_out <- loan_clean_red_out[scores(loan_clean_red_out$term_in_months,type="chisq", prob=0.95) == FALSE,]
loan_clean_red_out <- loan_clean_red_out[loan_clean_red_out$term_in_months != outlier(loan_clean_red_out$term_in_months, opposite = TRUE),]
hist(loan_clean_red_out$term_in_months)
hist(log(loan_clean_red_out$term_in_months))
summary(loan_clean_red_out$term_in_months)
```

remove outliers in duration per dollar
```{r}
loan_clean_red_out <- loan_clean_red_out[scores(loan_clean_red_out$duration_perdollar,type="chisq", prob=0.95) == FALSE,]
loan_clean_red_out <- loan_clean_red_out[loan_clean_red_out$duration_perdollar != outlier(loan_clean_red_out$duration_perdollar, opposite = TRUE),]
hist(loan_clean_red_out$duration_perdollar)
hist(log(loan_clean_red_out$duration_perdollar))
summary(log(loan_clean_red_out$duration_perdollar))
```

merging (cleaned MPI) and remove NULL
```{r}
comp <- merge(loan_clean_red_out, mpi, by="country", all.x=TRUE)
comp <- comp[is.na(comp$MPI) == FALSE,]
sum(is.na(comp$MPI))
```

Checking correlation on numerical variables
```{r}
cor(comp[,c(2,4,11)], method = "spearman")
```

forward and backward selection
```{r}
mlr_full <- lm(duration_perdollar ~ funded_amount + sector + term_in_months + borrower_genders + repayment_interval + funded_yearmonth + posted_yearmonth + MPI + country, data = comp)
mlr_null <- lm(duration_perdollar ~ 1, data = comp)
summary(mlr_full)
summary(mlr_null)
step_F <- stepAIC(mlr_null, scope = list(lower = mlr_null, upper = mlr_full), direction = "forward", trace = TRUE)
summary(step_F)
step_B <- stepAIC(mlr_full, direction = "backward", trace = TRUE)
summary(step_B)
```

Multiple Linear Regression
```{r}
reg_mlr <- lm(duration_perdollar ~ funded_amount + sector + term_in_months + borrower_genders + repayment_interval + funded_yearmonth + posted_yearmonth + MPI, data = comp)
```

Normalize and Multiple Linear regression
```{r}
normalize <- function(x) {
               return ((x - min(x)) / (max(x) - min(x))) }
comp_norm <- cbind(as.data.frame(lapply(comp[,c(2,4,7,11)], normalize)), country = comp$country, sector = comp$sector, borrower_genders = comp$borrower_genders, repayment_interval = comp$repayment_interval, funded_yearmonth = comp$funded_yearmonth, posted_yearmonth = comp$posted_yearmonth)
norm_mlr <- lm(duration_perdollar ~ funded_amount + sector + term_in_months + borrower_genders + repayment_interval + funded_yearmonth + posted_yearmonth + MPI, data = comp_norm)
summary(norm_mlr)
```

Log-log transform and Multiple Linear Regression
```{r}
comp_log <- cbind(as.data.frame(log(comp[,c(2,4,7,11)])), country = comp$country, sector = comp$sector, borrower_genders = comp$borrower_genders, repayment_interval = comp$repayment_interval, funded_yearmonth = comp$funded_yearmonth, posted_yearmonth = comp$posted_yearmonth)
log_mlr <- lm(duration_perdollar ~ funded_amount + sector + term_in_months + borrower_genders + repayment_interval + funded_yearmonth + posted_yearmonth + MPI, data = comp_log)
summary(log_mlr)
```

Split training/test 70/30 - regular dataset
```{r}
comp_train_index <- sample(1:nrow(comp), 0.7 * nrow(comp))
comp_train <- comp[comp_train_index,]
comp_test <- comp[-comp_train_index,]
```

10-Fold Cross-validation to check overfitting for Multiple Linear Regression - regular dataset
```{r}
comp_train_control <- trainControl(method = "cv", number = 10)
reg_mlr_cv <- train(duration_perdollar ~ funded_amount + sector + term_in_months + borrower_genders + repayment_interval + funded_yearmonth + posted_yearmonth + MPI, data = comp_train, method = "lm", trControl = comp_train_control)
reg_mlr_cv$resample
reg_mlr_cv$results
```

Multiple Linear Regression Prediction evaluated on rmse and % of cases with less than 25% error - regular dataset
```{r}
reg_mlr_model <- lm(duration_perdollar ~ funded_amount + sector + term_in_months + borrower_genders + repayment_interval + funded_yearmonth + posted_yearmonth + MPI, data = comp_train)
reg_mlr_predict <- predict(reg_mlr_model, interval = "prediction", newdata = comp_test)
errors_reg_mlr <- reg_mlr_predict[,"fit"] - comp_test$duration_perdollar
hist(errors_reg_mlr)
rmse_reg_mlr <- sqrt(mean(errors_reg_mlr^2))
rel_change_reg_mlr <- abs(errors_reg_mlr) / comp_test$duration_perdollar
pred25_reg_mlr <- table(rel_change_reg_mlr <0.25)["TRUE"] / nrow(comp_test)
predrate_reg_mlr <- rmse_reg_mlr / mean(comp_test$duration_perdollar)
paste("RMSE", rmse_reg_mlr)
paste("PRED(25)", pred25_reg_mlr)
paste("PRED ERROR RATE", predrate_reg_mlr)
```

Split training/test 70/30 - normalized dataset
```{r}
comp_norm_train_index <- sample(1:nrow(comp_norm), 0.7 * nrow(comp_norm))
comp_norm_train <- comp_norm[comp_norm_train_index,]
comp_norm_test <- comp_norm[-comp_norm_train_index,]
```

10-Fold Cross-validation to check overfitting for Multiple Linear Regression - normalized dataset
```{r}
norm_mlr_cv <- train(duration_perdollar ~ funded_amount + sector + term_in_months + borrower_genders + repayment_interval + funded_yearmonth + posted_yearmonth + MPI, data = comp_norm_train, method = "lm", trControl = comp_train_control)
norm_mlr_cv$resample
norm_mlr_cv$results
```

Multiple Linear Regression Prediction evaluated on rmse and % of cases with less than 25% error - normalized dataset
```{r}
norm_mlr_model <- lm(duration_perdollar ~ funded_amount + sector + term_in_months + borrower_genders + repayment_interval + funded_yearmonth + posted_yearmonth + MPI, data = comp_norm_train)
norm_mlr_predict <- predict(norm_mlr_model, interval = "prediction", newdata = comp_norm_test)
errors_norm_mlr <- norm_mlr_predict[,"fit"] - comp_norm_test$duration_perdollar
hist(errors_norm_mlr)
rmse_norm_mlr <- sqrt(mean(errors_norm_mlr^2)) * (max(comp$duration_perdollar) - min(comp$duration_perdollar))
rel_change_norm_mlr <- abs(errors_norm_mlr) / comp_norm_test$duration_perdollar
pred25_norm_mlr <- table(rel_change_norm_mlr<0.25)["TRUE"] / nrow(comp_norm_test)
predrate_norm_mlr <- rmse_norm_mlr / (mean(comp_norm_test$duration_perdollar) * (max(comp$duration_perdollar) - min(comp$duration_perdollar)))
paste("RMSE", rmse_norm_mlr)
paste("PRED(25)", pred25_norm_mlr)
paste("PRED ERROR RATE", predrate_norm_mlr)
```

Split training/test 70/30 - log dataset
```{r}
comp_log_train_index <- sample(1:nrow(comp_log), 0.7 * nrow(comp_log))
comp_log_train <- comp_log[comp_log_train_index,]
comp_log_test <- comp_log[-comp_log_train_index,]
```

10-Fold Cross-validation to check overfitting for Multiple Linear Regression - log dataset
```{r}
log_mlr_cv <- train(duration_perdollar ~ funded_amount + sector + term_in_months + borrower_genders + repayment_interval + funded_yearmonth + posted_yearmonth + MPI, data = comp_log_train, method = "lm", trControl = comp_train_control)
log_mlr_cv$resample
log_mlr_cv$results
```

Multiple Linear Regression Prediction evaluated on rmse and % of cases with less than 25% error - log dataset
```{r}
log_mlr_model <- lm(duration_perdollar ~ funded_amount + sector + term_in_months + borrower_genders + repayment_interval + funded_yearmonth + posted_yearmonth + MPI, data = comp_log_train)
log_mlr_predict <- predict(log_mlr_model, interval = "prediction", newdata = comp_log_test)
errors_log_mlr <- exp(log_mlr_predict[,"fit"]) - exp(comp_log_test$duration_perdollar)
hist(errors_log_mlr)
rmse_log_mlr <- sqrt(mean(errors_log_mlr)^2)
rel_change_log_mlr <- abs(errors_log_mlr) / exp(comp_log_test$duration_perdollar)
pred25_log_mlr <- table(rel_change_log_mlr <0.25)["TRUE"] / nrow(comp_log_test)
predrate_log_mlr <- rmse_log_mlr / mean(comp_test$duration_perdollar)
paste("RMSE", rmse_log_mlr)
paste("PRED(25)", pred25_log_mlr)
paste("PRED ERROR RATE", predrate_log_mlr)
```

10-Fold validation to check overfitting for Regression Tree - regular dataset
```{r}
reg_rt_cv <- train(duration_perdollar ~ funded_amount + sector + term_in_months + borrower_genders + repayment_interval + funded_yearmonth + posted_yearmonth + MPI, data = comp_train, method = "rpart", trControl = comp_train_control)
reg_rt_cv$resample
reg_rt_cv$results
```

Regression tree Prediction evaluated on rmse and % of cases with less than 25% error - regular dataset
```{r}
reg_rt_model <- rpart(duration_perdollar ~ funded_amount + sector + term_in_months + borrower_genders + repayment_interval + funded_yearmonth + posted_yearmonth + MPI, data = comp_train, method = "anova")
reg_rt_model <- prune(reg_rt_model,cp=reg_rt_model$cptable[which.min(reg_rt_model$cptable[,"xerror"]),"CP"])
reg_rt_predict <- predict(reg_rt_model, interval = "prediction", newdata = comp_test)
errors_reg_rt <- reg_rt_predict - comp_test$duration_perdollar
hist(errors_reg_rt)
rmse_reg_rt <- sqrt(mean(errors_reg_rt^2))
rel_change_reg_rt <- abs(errors_reg_rt) / comp_test$duration_perdollar
pred25_reg_rt <- table(rel_change_reg_rt<0.25)["TRUE"] / nrow(comp_test)
predrate_reg_rt <- rmse_reg_rt / mean(comp_test$duration_perdollar)
paste("RMSE", rmse_reg_rt)
paste("PRED(25)", pred25_reg_rt)
paste("PRED ERROR RATE", predrate_reg_rt)
```

10-Fold validation to check overfitting for Regression Tree - normalized dataset
```{r}
norm_rt_cv <- train(duration_perdollar ~ funded_amount + sector + term_in_months + borrower_genders + repayment_interval + funded_yearmonth + posted_yearmonth + MPI, data = comp_norm_train, method = "rpart", trControl = comp_train_control)
norm_rt_cv$resample
norm_rt_cv$results
```

Regression Tree Prediction evaluated on rmse and % of cases with less than 25% error - normalized dataset
```{r}
norm_rt_model <- rpart(duration_perdollar ~ funded_amount + sector + term_in_months + borrower_genders + repayment_interval + funded_yearmonth + posted_yearmonth + MPI, data = comp_norm_train, method = "anova")
norm_rt_model <- prune(norm_rt_model,cp=norm_rt_model$cptable[which.min(norm_rt_model$cptable[,"xerror"]),"CP"])
norm_rt_predict <- predict(norm_rt_model, interval = "prediction", newdata = comp_norm_test)
errors_norm_rt <- norm_rt_predict - comp_norm_test$duration_perdollar
hist(errors_norm_rt)
rmse_norm_rt <- sqrt(mean(errors_norm_rt^2)) * (max(comp$duration_perdollar) - min(comp$duration_perdollar))
rel_change_norm_rt <- abs(errors_norm_rt) / comp_norm_test$duration_perdollar
pred25_norm_rt <- table(rel_change_norm_rt <0.25)["TRUE"] / nrow(comp_norm_test)
predrate_norm_rt <- rmse_norm_rt / (mean(comp_norm_test$duration_perdollar) * (max(comp$duration_perdollar) - min(comp$duration_perdollar)))
paste("RMSE", rmse_norm_rt)
paste("PRED(25)", pred25_norm_rt)
paste("PRED ERROR RATE", predrate_norm_rt)
```
